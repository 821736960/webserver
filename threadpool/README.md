
半同步/半反应堆线程池
===============
使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。
> * 同步I/O模拟proactor模式
> * 半同步/半反应堆
> * 线程池

老张爱喝茶，废话不说，煮开水。 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。 1 老张把水壶放到火上，立等水开。（同步阻塞） 老张觉得自己有点傻 2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞） 老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀的噪音。 3 老张把响水壶放到火上，立等水开。（异步阻塞） 老张觉得这样傻等意义不大 4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞） 老张觉得自己聪明了。

所谓同步异步，只是对于水壶而言。 普通水壶，同步；响水壶，异步。 虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。 同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。

所谓阻塞非阻塞，仅仅对于老张而言。 立等的老张，阻塞；看电视的老张，非阻塞。 情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用

5种I/O模型,阻塞会发生在两个阶段上:

1.阻塞式I/O 等待数据时阻塞 数据从内核复制到用户空间时阻塞 2.非阻塞式I/O 等待数据不阻塞,但是轮询会占用cpu资源 数据从内核复制到用户空间时阻塞 3.I/O复用 考虑到轮询占用cpu资源的问题,阻塞在选择器上,减轻处理器负担 将数据从内核复制到用户空间时阻塞 4.信号驱动式I/O 等待数据不阻塞,数据准备好时通知接收数据,将数据从内核复制到用户空间时阻塞

以上四种或多或少均有阻塞现象存在,它们都是同步I/O模型

5.异步I/O 等待数据时不阻塞 将数据从内核复制到用户空间时也不阻塞. 数据到了用户空间以后才发信号,就像你在网上下了订单,快递员拿着你的快件站在你家门口才通知你开门签收的样子.

而在网上下了订单,货物到了离你家最近的自提点,商城通知你去自提点取提货.你专门抽出时间去提货.这是4.信号驱动式I/O.因为在来回自提点的路上你其实是阻塞的.





